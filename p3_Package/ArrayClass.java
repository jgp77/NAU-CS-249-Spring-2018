package p3_Package;

/**
 * @author Joshua Pollock
 */
public class ArrayClass
{

    public static final int FAILED_ACCESS = -999999;
    /**
     *
     */
    private static final int DEFAULT_CAPACITY = 10;
    private int arrayCapacity;
    private int arraySize;
    private int[] localArray;

    /*
     * Default constructor, initializes array to default capacity (10)
     */
    public ArrayClass()
    {
        localArray = new int[ DEFAULT_CAPACITY ];
        arrayCapacity = DEFAULT_CAPACITY;
        arraySize = 0;
    }

    /*
     * Initializing constructor, initializes array to specified capacity
     *
     * @param capacity Maximum capacity specification for the array
     */
    public ArrayClass( int capacity )
    {
        localArray = new int[ capacity ];
        arrayCapacity = capacity;
        arraySize = 0;
    }

    /**
     * Initializing constructor, initializes array to specified capacity, size
     * to specified value, then fills all elements with specified size value
     *
     * @param capacity  Maximum capacity specification for the array
     * @param size      Sets the number of items to be filled in array, and sets
     *                  the size of the ArrayClass object
     * @param fillValue Value to be placed in all elements of initialized array
     *                  up to the size
     */
    public ArrayClass( int capacity, int size, int fillValue )
    {
        int index;

        localArray = new int[ capacity ];
        arrayCapacity = capacity;
        arraySize = size;
        for(index = 0; index < arraySize; index++)
        {
            localArray[ index ] = fillValue;
        }
    }

    /**
     * Copy constructor, initializes array to size and capacity of copied array,
     * then copies only the elements up to the given size
     *
     * @param copied ArrayClass object to be copied
     */
    public ArrayClass( ArrayClass copied )
    {
        int index;

        arrayCapacity = copied.arrayCapacity;
        arraySize = copied.arraySize;
        localArray = new int[ this.arrayCapacity ];

        for(index = 0; index < arraySize; index++)
        {
            localArray[ index ] = copied.localArray[ index ];
        }
    }

    /**
     * Loads a specified number of unique random numbers in object
     * <p>
     * Note: This method overwrites all data in the array up to the number of
     * randoms requested
     * <p>
     * Note: If requested number of randoms is greater than the array capacity,
     * the array is resized
     * <p>
     * Note: Size is set to number of random numbers requested
     * <p>
     * Exceptional Condition: If more values are requested than are possible
     * given the range of numbers, method returns false, otherwise, it returns
     * true
     *
     * @param numRands  Number of random values requested
     * @param lowLimit  Lowest value to be generated
     * @param highLimit Highest value to be generated
     *
     * @return Boolean true if method successful; false otherwise
     */
    public boolean loadUniqueRandoms( int numRands, int lowLimit,
                                      int highLimit )
    {
        int index, randNum;

        if(numRands > ( highLimit - lowLimit ) || lowLimit > highLimit)
        {
            return false;
        }

        if(numRands > arrayCapacity)
        {
            resize( numRands );
        }

        clear();

        for(index = 0; index < numRands; index++)
        {
            randNum = getRandBetween( lowLimit, highLimit );
            if(!isInArray( randNum ))
            {
                appendItem( randNum );
            }
            else
            {
                index--;
            }
        }
        arraySize = numRands;
        return true;

    }

    /**
     * Tests for value found in object array; returns true if value within
     * array, false otherwise
     *
     * @param testVal Value to be tested
     *
     * @return Boolean true if value is found in array, false otherwise
     */
    public boolean isInArray( int testVal )
    {
        int index;

        for(index = 0; index < arraySize; index++)
        {
            if(localArray[ index ] == testVal)
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Generates random number between given low and high values
     *
     * @param low  Lowest value that will be generated by method
     * @param high Highest value that will be generated by method
     *
     * @return The generated random value
     */
    private int getRandBetween( int low, int high )
    {
        return (int) ( Math.random() * ( high - low ) + low );
    }

    /**
     * Tests for size of array equal to capacity, no more values can be added
     *
     * @return Boolean result of test for full
     */
    public boolean isFull()
    {
        return arraySize == arrayCapacity;
    }

    /**
     * Tests for size of array equal to zero, no valid values stored in array
     *
     * @return Boolean result of test for empty
     */
    public boolean isEmpty()
    {
        return arraySize == 0;
    }

    /**
     * Appends item to end of array, if array is not full, e.g., no more values
     * can be added
     *
     * @param newValue Value to be appended to array
     *
     * @return Boolean success if appended, or failure if array was full
     */
    public boolean appendItem( int newValue )
    {
        if(!isFull())
        {
            localArray[ arraySize ] = newValue;
            arraySize++;
            return true;
        }
        return false;
    }

    /**
     * Description: Inserts item to array at specified index if array is not
     * full, e.g., no more values can be added
     * <p>
     * Note: Value is inserted at given index, all data from that index to the
     * end of the array is shifted up by one
     * <p>
     * Note: Value can be inserted after the last valid element but not at any
     * index past that point
     *
     * @param insertIndex Index of element into which value is to be inserted
     * @param newValue    Value to be inserted into array
     *
     * @return Boolean success if inserted, or failure if array was full
     */
    public boolean insertItemAt( int insertIndex, int newValue )
    {
        int index;

        if(!isFull() && insertIndex >= 0 && insertIndex <= arraySize)
        {
            index = arraySize;
            while(index > insertIndex)
            {
                localArray[ index ] = localArray[ index-- ];
                index--;
            }
            localArray[ index ] = newValue;
            arraySize++;
            return true;
        }

        return false;
    }

    /**
     * Accesses item in array at specified index if index within array size
     * bounds
     *
     * @param accessIndex Index of requested element value
     *
     * @return Accessed value if successful, FAILED_ACCESS (-999999) if not
     */
    public int accessItemAt( int accessIndex )
    {
        if(accessIndex >= 0 && accessIndex < arraySize)
        {
            return localArray[ accessIndex ];
        }

        return FAILED_ACCESS;
    }

    /**
     * Description: Removes item from array at specified index if index within
     * array size bounds
     * <p>
     * Note: Each data item from the element immediately above the remove index
     * to the end of the array is moved down by one element
     *
     * @param removeIndex Index of element value to be removed
     *
     * @return Removed value if successful, FAILED_ACCESS (-999999) if not
     */
    public int removeItemAt( int removeIndex )
    {
        int index, removedItem;

        if(removeIndex >= 0 && removeIndex < arraySize)
        {
            removedItem = localArray[ removeIndex ];
            index = removeIndex;
            arraySize--;

            while(index < arraySize)
            {
                localArray[ index ] = localArray[ index++ ];
                index++;
            }
            return removedItem;
        }

        return FAILED_ACCESS;
    }

    /**
     * Description: Resets array capacity, copies current size and current size
     * number of elements
     * <p>
     * Exception: Method will not resize capacity below current array size,
     * returns false if this is attempted, true otherwise
     *
     * @param newCapacity New capacity to be set; must be larger than current
     *                    capacity
     *
     * @return Boolean condition of resize success or failure
     */
    public boolean resize( int newCapacity )
    {
        int index;
        int[] resizedArr = new int[ newCapacity ];

        if(newCapacity > arrayCapacity)
        {
            for(index = 0; index < arraySize; index++)
            {
                resizedArr[ index ] = localArray[ index ];
            }
            arrayCapacity = newCapacity;
            localArray = resizedArr;
            return true;
        }

        return false;
    }

    /**
     * Data sorted using merge sort algorithm
     * <p>
     * Note: Call runMergeSortHelper with lower and upper indices of array to be
     * sorted
     */
    public void runMergeSort()
    {
        runMergeSortHelper( 0, arraySize - 1 );
    }

    /**
     * Merge sort helper, places low and high indices of array segment to be
     * processed into recursive method, then sorts data using merge sort
     * algorithm
     *
     * @param lowIndex  Lowest index of array segment to be managed; this varies
     *                  as the segments are broken down recursively
     * @param highIndex Highest index of array segment to be managed; this
     *                  varies as the segments are broken down recursively
     */
    private void runMergeSortHelper( int lowIndex, int highIndex )
    {
        int middleIndex;
        if(lowIndex < highIndex)
        {
            middleIndex = ( lowIndex + highIndex ) / 2;
            runMergeSortHelper( lowIndex, middleIndex );
            runMergeSortHelper( middleIndex + 1, highIndex );
            runMerge( lowIndex, middleIndex, highIndex );
        }
    }

    /**
     * Merges values brought in between a low and high index segment of an
     * array
     * <p>
     * Note: uses locally sized single array for temporary storage
     *
     * @param lowIndex    Lowest index of array segment to be managed
     * @param middleIndex Middle index of array segment to be managed
     * @param highIndex   High index of array segment to be managed
     */
    private void runMerge( int lowIndex, int middleIndex, int highIndex )
    {
        int leftIndex = lowIndex, rightIndex =
                middleIndex + 1, position = leftIndex;
        int[] mergeArray = new int[ arrayCapacity ];
        for(int i = lowIndex; i <= highIndex; i++)
        {
            mergeArray[ i ] = localArray[ i ];
        }
        while(leftIndex <= middleIndex || rightIndex <= highIndex)
        {
            if(leftIndex <= middleIndex && rightIndex <= highIndex)
            {
                if(mergeArray[ leftIndex ] <= mergeArray[ rightIndex ])
                {
                    localArray[ position ] = mergeArray[ leftIndex ];
                    leftIndex += 1;
                }
                else
                {
                    localArray[ position ] = mergeArray[ rightIndex ];
                    rightIndex += 1;
                }
            }
            else if(leftIndex <= middleIndex)
            {
                localArray[ position ] = mergeArray[ leftIndex ];
                leftIndex += 1;
            }
            else if(rightIndex <= highIndex)
            {
                localArray[ position ] = mergeArray[ rightIndex ];
                rightIndex += 1;
            }
            position += 1;
        }
    }

    /**
     * Data sorted using quick sort algorithm
     * <p>
     * Note: Call runQuickSortHelper with lower and upper indices of array to be
     * sorted
     */
    public void runQuickSort()
    {
        runQuickSortHelper( 0, arraySize - 1 );
    }

    /**
     * Helper method run with parameters that support recursive access
     *
     * @param lowIndex  Low index of the segment of the array to be processed
     * @param highIndex High index of the segment of the array to be processed
     */
    private void runQuickSortHelper( int lowIndex, int highIndex )
    {
        int index = runPartition( lowIndex, highIndex );

        if(lowIndex < index - 1)
        {
            runQuickSortHelper( lowIndex, index - 1 );

        }
        if(index < highIndex)
        {
            runQuickSortHelper( index, highIndex );

        }
    }

    /**
     * Partitions array using the first value as the partition; when this method
     * is complete the partition value is in the correct location in the array
     *
     * @param lowIndex  Low index of array segment to be partitioned
     * @param highIndex High index of array segment to be partitioned
     *
     * @return Integer index of partition pivot
     */
    private int runPartition( int lowIndex, int highIndex )
    {
        int leftIndex = lowIndex, rightIndex = highIndex, middleIndex =
                ( lowIndex + highIndex ) / 2, pivot = localArray[ middleIndex ];
        while(leftIndex <= rightIndex)
        {
            while(localArray[ leftIndex ] < pivot)
            {
                leftIndex++;
            }
            while(localArray[ rightIndex ] > pivot)
            {
                rightIndex--;
            }
            if(leftIndex <= rightIndex)
            {
                swapValuesAtIndex( rightIndex, leftIndex );
                leftIndex++;
                rightIndex--;
            }
        }
        return leftIndex;
    }

    /**
     * Data sorted using shell sort algorithm
     */
    public void runShellSort()
    {
        int arrSize = arraySize, gap, index, secondIndex;

        for(gap = arrSize / 2; gap > 0; gap /= 2)
        {
            for(index = gap; index < arrSize; index++)
            {
                for(secondIndex = index; secondIndex >= gap; secondIndex -= gap)
                {
                    if(localArray[ index - gap ] > localArray[ index ])
                    {
                        swapValuesAtIndex( secondIndex, secondIndex - gap );
                    }
                }

            }
        }
    }

    /**
     * Swaps values in the object array by taking in the indices of the array
     * locations
     * <p>
     * Note: for a small level of optimization, this method does not swap values
     * if the indices are the same
     *
     * @param oneIndex   Index of the of the values to be swapped
     * @param otherIndex Index of the other value to be swapped
     */
    private void swapValuesAtIndex( int oneIndex, int otherIndex )
    {
        int tmpVal = localArray[ oneIndex ];

        localArray[ oneIndex ] = localArray[ otherIndex ];

        localArray[ otherIndex ] = tmpVal;
    }

    /**
     * Description: Gets current size of array
     * <p>
     * Note: Size of array indicates number of valid or viable values in the
     * array
     *
     * @return Size of array
     */
    public int getCurrentSize()
    {
        return arraySize;
    }

    /**
     * Description: Gets current capacity of array
     * <p>
     * Note: Capacity of array indicates number of values the array can hold
     *
     * @return Capacity of array
     */
    public int getCurrentCapacity()
    {
        return arrayCapacity;
    }

    /**
     * Clears array of all valid values by setting array size to zero, values
     * remain in array but are not accessible
     */
    public void clear()
    {
        arraySize = 0;
    }
}
